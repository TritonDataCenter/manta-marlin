#!/usr/node/bin/node

var mod_assert = require('assert');
var mod_carrier = require('carrier');
var mod_child_process = require('child_process');
var mod_crypto = require('crypto');
var mod_getopt = require('posix-getopt');

/*
 * msplit: demux streams to send to multiple reducers
 */
var msUsageMessage = [
	'usage: msplit [-n number_of_reducers] [-d delimiter] [-f field list]',
	'',
	'msplit is used to split a stream into many mpipes, one per the number',
	'of reducers for your job.  The -n option specifies the number of',
	'reducers your job has and must match the number of reducers for the',
	'next phase of your job.',
	'',
	'The -d and -f fields are optional and specify the delimiter to use',
	'when splitting fields and the field list to use to construct the key',
	'used to map to reducers.  The delimeter defaults to (tab).  The field',
	'defaults to 1.  If the field does not exist (if it is out of range,',
	'for example), it will simply not be part of the partitioning key.',
	'The implications of this is that if all fields are invalid all output',
	'will go to the same reducer.',
	'',
	'For example, to split on comma and use the 5th and 3rd fields to ',
	'demux to 4 reducers:',
	'... | msplit -d \',\' -f 5,3 -n 4'
].join('\n');

var msDelimiter = '\t';
var msFields = [1];
var msHashAlgo = 'md5';
var msPipes = [];
var msNumReducers = null;

function main() {
	var carrier;
	var i = 0;
	var option;
	var parser;

	parser = new mod_getopt.BasicParser('d:f:n:', process.argv);

	while ((option = parser.getopt()) !== undefined) {
		switch (option.option) {
		case 'd':
			msDelimiter = option.optarg;
			if (msDelimiter === '\n') {
				console.error('msplit: cannot use newline as ' +
					      'a delimiter.');
				usage();
			}
			break;

		case 'f':
			msFields = option.optarg.split(',');
			for (i = 0; i < msFields.length; ++i) {
				msFields[i] = parseInt(msFields[i], 10);
				if (isNaN(msFields[i])) {
					console.error('msplit: invalid field');
					usage();
				}
			}
			break;

		case 'n':
			msNumReducers = parseInt(option.optarg, 10);
			if (isNaN(msNumReducers)) {
				console.error('msplit: invalid number of ' +
					      'reducers');
				usage();
			}
			break;

		default:
			/* error message already emitted by getopt */
			mod_assert.equal('?', option.option);
			usage();
			break;
		}
	}

	if (!msNumReducers) {
		console.error('Number of reducers must be specified.');
		usage();
	}

	// Pipes
	for (i = 0; i < msNumReducers; ++i) {
		var spawn = createReducerPipe(i);
		msPipes.push(spawn);
	}

	// Carrier takes care of the rest
	carrier = mod_carrier.carry(process.stdin);

	carrier.on('line', function (line) {
		var r = selectReducer(line, msDelimiter, msFields,
				      msNumReducers);
		msPipes[r].stdin.write(line + '\n');
	});

	carrier.on('end', function () {
		for (i = 0; i < msNumReducers; ++i) {
			msPipes[i].stdin.end();
		}
	});

	process.stdin.resume();
}

function selectReducer(line, delimeter, fields, nReducers) {
	var parts = line.split(delimeter);
	var key = '';
	for (var i = 0; i < fields.length; ++i) {
		// Taking a page out of cut's playbook. if the field can't be
		// found we simply don't use it.
		if (!parts[fields[i] - 1]) {
			continue;
		}

		if (key) {
			key += delimeter;
		}
		// The - 1 here is because the fields are specified starting
		// at 1 and not 0.
		key += parts[fields[i] - 1];
	}
	var hash = mod_crypto.createHash(msHashAlgo);
	hash.update(key);
	var digest = hash.digest('hex');
	var digestNumber = parseInt(digest.substr(0, 8), 16);
	return (digestNumber % nReducers);
}

function createReducerPipe(reducer) {
	return (mod_child_process.spawn('mpipe', ['-r', reducer]));
}

function usage()
{
	console.error(msUsageMessage);
	process.exit(2);
}

function msFatal(message)
{
	console.error(message);
	process.exit(1);
}

main();
