#!/usr/bin/env node

/*
 * mpoll: poll on a Moray bucket with a given search filter, printing out new
 * and modified objects in real-time.
 */

var mod_path = require('path');
var mod_url = require('url');

var mod_bunyan = require('bunyan');
var mod_moray = require('moray');
var mod_getopt = require('posix-getopt');
var mod_wordwrap = require('wordwrap');
var wrap = mod_wordwrap(80);

var mod_mamoray = require('../lib/moray');
var mod_mautil = require('../lib/util');

var mpUsage =  [
    'usage: %s [-t timeout] [-v] url bucket filter\n',
    wrap('Periodically searches bucket "bucket" on the Moray service at ' +
    '"url" with filter "filter" and prints out which objects have changed.  ' +
    '"url" should be of the form "tcp://hostname:port/".'),
    '\nOptions:\n',
    '    -t timeout    Wait at least "timeout" milliseconds between polls',
    '    -v            Verbose mode.'
].join('\n');

var mpArg0 = mod_path.basename(process.argv[1]);
var mpInterval = 1000;
var mpVerbose = 0;
var mpBucket, mpFilter;

var mpLog;
var mpClient;
var mpCache;
var mpStarted;

function main()
{
	var parser, option, url;

	parser = new mod_getopt.BasicParser('t:v', process.argv);
	
	while ((option = parser.getopt()) !== undefined) {
		switch (option.option) {
		case 't':
			mpInterval = parseInt(option.optarg, 10);
			if (isNaN(mpInterval)) {
				console.error('%s: invalid value for -t: "%s"',
				    mpArg0, option.optarg);
				usage();
			}
			break;
	
		case 'v':
			mpVerbose++;
			break;
	
		default:
			/* error message already emitted by getopt */
			mod_assert.equal('?', option.option);
			usage();
			break;
		}
	}
	
	if (parser.optind() + 2 >= process.argv.length)
		usage();

	url = process.argv[parser.optind()];
	mpBucket = process.argv[parser.optind() + 1];
	mpFilter = process.argv[parser.optind() + 2];

	mpLog = new mod_bunyan({
	    'name': 'mpoll',
	    'level': process.env['LOG_LEVEL'] || 'info'
	});

	urlconf = mod_url.parse(url);

	if (!urlconf['hostname'] || !urlconf['port']) {
		console.error('%s: invalid url: "%s"', mpArg0, url);
		usage();
	}

	mpClient = mod_moray.createClient({
	    'host': urlconf['hostname'],
	    'port': parseInt(urlconf['port'], 10),
	    'log': mpLog.child({ 'component': 'client' }),
	    'reconnect': true
	});

	mpCache = new mod_mamoray.MorayEtagCache();

	mpCache.on('record', function (record, haschanged) {
		console.log('%s %d/%s (etag%s changed)',
		    record['key'], record['_mtime'], record['_etag'],
		    haschanged ? '' : ' not');
	});

	mpClient.on('connect', function () {
		console.error('%s: connected', mpArg0);
		if (!mpStarted)
			mpStarted = setTimeout(tick, 0);
	});

	mpClient.on('close', function () {
		console.error('%s: disconnected (and retries exhausted)',
		    mpArg0);
		process.exit(1);
	});

	mpClient.on('error', function (err) {
		console.error('%s: client error: %s', mpArg0, err.message);
	});
}

function usage()
{
	console.error(mpUsage, mpArg0);
	process.exit(2);
}

function tick()
{
	var req;

	if (mpVerbose)
		console.error('%s: begin request', mpArg0);

	req = mpClient.findObjects(mpBucket, mpFilter, { 'noCache': true });

	req.on('error', function (err) {
		console.error('%s: request error: %s', mpArg0, err.message);
		if (mpVerbose)
			console.error('%s: end request (error)', mpArg0);
		setTimeout(tick, mpInterval);
	});

	req.on('end', function () {
		if (mpVerbose)
			console.error('end request');
		setTimeout(tick, mpInterval);
	});

	req.on('record', function (record) {
		if (mpVerbose) {
			console.log('  record: %s %d/%s', record['key'],
			    record['_mtime'], record['_etag']);
			if (mpVerbose > 1)
				console.log(record['value']);
		}

		mpCache.record(record);
	});
}

main();
