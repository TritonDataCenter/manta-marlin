#!/usr/node/bin/node

var mod_assert = require('assert');
var mod_fs = require('fs');
var mod_getopt = require('posix-getopt');
var mod_http = require('http');
var mod_path = require('path');
var mod_uuid = require('node-uuid');

/*
 * mpipe: distributed pipe
 */
var dpUsageMessage = [
    'usage: mpipe [-r reducer] [objectkey]',
    '',
    'mpipe is a distributed pipe for compute jobs.  This command reads data',
    'from stdin and saves it as a new object called "objectkey".  The new ',
    'object is recorded as an output object for the current task.  If ',
    '"objectkey" is unspecified, a unique key will be created.',
    '',
    'Because the object store requires knowing content-length ahead of time, ',
    'this command buffers input to the local filesystem before uploading any ',
    'of it.',
    '',
    'If -r is specified, then "reducer" must be an integer between 0 and the ',
    'number of concurrent reducers in the next phase of the job.  The object ',
    'will be marked for processing by that reducer.  If -r is not specified ',
    'and multiple reducers are in use, the object will be routed to one at ',
    'random.'
].join('\n');

var dpTmpfile = '/var/tmp/mpipe.' + process.pid;
var dpObjkey, dpReducer;
var dpOutstream, dpInstream;

function main()
{
	var parser, option;

	parser = new mod_getopt.BasicParser('r:', process.argv);

	while ((option = parser.getopt()) !== undefined) {
		switch (option.option) {
		case 'r':
			dpReducer = parseInt(option.optarg, 10);
			if (isNaN(dpReducer)) {
				console.error('mpipe: invalid reducer');
				usage();
			}
			break;

		default:
			/* error message already emitted by getopt */
			mod_assert.equal('?', option.option);
			usage();
			break;
		}
	}

	if (parser.optind() < process.argv.length) {
		dpObjkey = process.argv[parser.optind()];
	} else if (process.env['MANTA_OUTPUT_BASE']) {
		dpObjkey = process.env['MANTA_OUTPUT_BASE'] + mod_uuid.v4();
	} else {
		/*
		 * User programs invoking "mpipe" are expected to pass through
		 * the environment they were created with, which will contain
		 * variables we need to name the output key appropriately.  If
		 * this becomes problematic for some use cases, we could fetch
		 * this information from the HTTP server inside the zone,
		 * obviously with some additional latency.
		 */
		console.error(
		    'mpipe: manta configuration not found in environment');
		process.exit(2);
	}

	console.error('saving stdin to %s', dpTmpfile);
	dpOutstream = mod_fs.createWriteStream(dpTmpfile);
	process.stdin.pipe(dpOutstream);
	process.stdin.resume();
	process.stdin.on('end', dpUploadFile);
}

function usage()
{
	console.error(dpUsageMessage);
	process.exit(2);
}

function dpFatal(message)
{
	console.error(message);
	process.exit(1);
}

function dpUploadFile()
{
	dpInstream = mod_fs.createReadStream(dpTmpfile);

	dpInstream.on('open', function () {
		mod_fs.stat(dpTmpfile, function (err, stat) {
			if (err)
				dpFatal('failed to stat ' + dpTmpfile +
				    ': ' + err.message);

			var uri = mod_path.join('/object', dpObjkey);
			console.error('uploading file to %s', uri);

			var headers = {
			    'content-length': stat['size']
			};

			if (dpReducer !== undefined)
				headers['x-marlin-reducer'] = dpReducer;

			var request = mod_http.request({
			    'host': 'localhost',
			    'port': 8080,
			    'method': 'PUT',
			    'path': uri,
			    'headers': headers
			});

			dpInstream.pipe(request);

			request.on('response', function (response) {
				if (response.statusCode != 201 &&
				    response.statusCode != 204)
					dpFatal('server returned ' +
					    response.statusCode);

				console.log(dpObjkey);
			});
		});
	});
}

main();
