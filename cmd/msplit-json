#!/usr/node/bin/node

var mod_assert = require('assert');
var mod_carrier = require('carrier');
var mod_child_process = require('child_process');
var mod_crypto = require('crypto');
var mod_getopt = require('posix-getopt');
var mod_json = require('jsontool');

/*
 * msplit: demux streams to send to multiple reducers
 */
var msUsageMessage = [
	'usage: msplit-json [-n number_of_reducers] [field list]',
	'',
	'msplit-json is used to split a stream of JSON into many mpipes, one',
	'per the number of reducers for your job.  The -n option specifies the',
	'number of reducers your job has and must match the number of reducers',
	'for the next phase of your job.',
	'',
	'If the field does not exist it will simply not be part of the ',
	'partitioning key.',
	'',
	'For example, to split on the values of the "foo" and "bar.baz" fields',
	'of each line to deumx to 4 reducers:',
	'... | msplit-json -n 4 foo bar.baz'
].join('\n');

var msDelimiter = '\t';
var msFields = [1];
var msHashAlgo = 'md5';
var msPipes = [];
var msNumReducers = null;

function main() {
	var carrier;
	var i = 0;
	var option;
	var parser;

	parser = new mod_getopt.BasicParser('n:', process.argv);

	while ((option = parser.getopt()) !== undefined) {
		switch (option.option) {
		case 'n':
			msNumReducers = parseInt(option.optarg, 10);
			if (isNaN(msNumReducers)) {
				console.error('msplit: invalid number of ' +
					      'reducers');
				usage();
			}
			break;

		default:
			/* error message already emitted by getopt */
			mod_assert.equal('?', option.option);
			usage();
			break;
		}
	}

	if (!msNumReducers) {
		console.error('Number of reducers must be specified.');
		usage();
	}

	msFields = process.argv.splice(parser.optind());
	if (msFields.length <= 0) {
		console.error('Must specify at least one field.');
		usage();
	}

	// Pipes
	for (i = 0; i < msNumReducers; ++i) {
		var spawn = createReducerPipe(i);
		msPipes.push(spawn);
	}

	// Carrier takes care of the rest
	carrier = mod_carrier.carry(process.stdin);

	carrier.on('line', function (line) {
		try {
			var obj = JSON.parse(line);
		} catch (e) {
			console.error('error: input is not json: %s', line);
			return;
		}
		var r = selectReducer(obj, msFields, msNumReducers);
		msPipes[r].stdin.write(line + '\n');
	});

	carrier.on('end', function () {
		for (i = 0; i < msNumReducers; ++i) {
			msPipes[i].stdin.end();
		}
	});

	process.stdin.resume();
}

function selectReducer(obj, fields, nReducers) {
	var key = '';
	for (var i = 0; i < fields.length; ++i) {
		var lookup = mod_json.parseLookup(fields[i]);
		var datum = mod_json.lookupDatum(obj, lookup);

		// Taking a page out of cut's playbook. if the field can't be
		// found we simply don't use it.
		if (datum === undefined) {
			continue;
		}

		key += datum;
	}
	var hash = mod_crypto.createHash(msHashAlgo);
	hash.update(key);
	var digest = hash.digest('hex');
	var digestNumber = parseInt(digest.substr(0, 8), 16);
	return (digestNumber % nReducers);
}

function createReducerPipe(reducer) {
	return (mod_child_process.spawn('mpipe', ['-r', reducer]));
}

function usage()
{
	console.error(msUsageMessage);
	process.exit(2);
}

function msFatal(message)
{
	console.error(message);
	process.exit(1);
}

main();
